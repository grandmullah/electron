<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIXOLON Service Connection Test</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .container { max-width: 900px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .header { text-align: center; margin-bottom: 30px; }
        .status { padding: 15px; margin: 15px 0; border-radius: 5px; }
        .status.connected { background: #d4edda; border: 1px solid #c3e6cb; color: #155724; }
        .status.disconnected { background: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; }
        .status.warning { background: #fff3cd; border: 1px solid #ffeaa7; color: #856404; }
        .status.info { background: #d1ecf1; border: 1px solid #bee5eb; color: #0c5460; }
        .test-section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
        button { padding: 12px 24px; margin: 8px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; }
        button:hover { background: #0056b3; }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        .log { background: #f8f9fa; padding: 15px; border-radius: 5px; font-family: monospace; max-height: 400px; overflow-y: auto; border: 1px solid #dee2e6; }
        .printer-info { background: #e7f3ff; padding: 15px; border-radius: 5px; border: 1px solid #b3d9ff; }
        .error { color: #dc3545; }
        .success { color: #28a745; }
        .info { color: #17a2b8; }
        .warning { color: #ffc107; }
        .connection-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0; }
        .connection-item { padding: 15px; border: 1px solid #ddd; border-radius: 5px; text-align: center; }
        .connection-item.success { border-color: #28a745; background: #f8fff9; }
        .connection-item.failed { border-color: #dc3545; background: #fff8f8; }
        .connection-item.pending { border-color: #ffc107; background: #fffef8; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîå BIXOLON Service Connection Test</h1>
            <p>Testing connection to BIXOLON Web Print SDK service on remote machine</p>
        </div>

        <div id="status" class="status warning">
            <h3>‚è≥ Initializing BIXOLON Service Test...</h3>
            <p>This will test various connection methods to reach your BIXOLON printer</p>
        </div>

        <div class="printer-info">
            <h3>üìã Your BIXOLON Configuration</h3>
            <ul>
                <li><strong>SDK:</strong> BIXOLON Web Print SDK V2.2.1</li>
                <li><strong>Printer:</strong> Bixolon SRP-350III (USB Connected)</li>
                <li><strong>Logical Name:</strong> Printer1</li>
                <li><strong>Location:</strong> Remote build machine</li>
                <li><strong>Connection:</strong> USB + Network Service</li>
            </ul>
        </div>

        <div class="test-section">
            <h3>üß™ Connection Tests</h3>
            <button onclick="testAllConnections()">Test All Connections</button>
            <button onclick="testSDKDetection()">Test SDK Detection</button>
            <button onclick="testServiceEndpoints()">Test Service Endpoints</button>
            <button onclick="testPrintJob()">Test Print Job</button>
            <button onclick="clearLog()">Clear Log</button>
        </div>

        <div class="test-section">
            <h3>üîó Connection Status</h3>
            <div class="connection-grid" id="connectionGrid">
                <div class="connection-item pending">
                    <h4>Global SDK</h4>
                    <p>Checking...</p>
                </div>
                <div class="connection-item pending">
                    <h4>HTTP :8080</h4>
                    <p>Pending...</p>
                </div>
                <div class="connection-item pending">
                    <h4>HTTP :3000</h4>
                    <p>Pending...</p>
                </div>
                <div class="connection-item pending">
                    <h4>HTTP :5000</h4>
                    <p>Pending...</p>
                </div>
                <div class="connection-item pending">
                    <h4>WebSocket :8080</h4>
                    <p>Pending...</p>
                </div>
                <div class="connection-item pending">
                    <h4>WebSocket :9100</h4>
                    <p>Pending...</p>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h3>üìù Test Log</h3>
            <div id="log" class="log"></div>
        </div>
    </div>

    <!-- Load BIXOLON integration scripts -->
    <script type="text/javascript" src="js/bGateWebPrintAPI_WS.js"></script>
    <script type="text/javascript" src="js/thermal-printer-simulator.js"></script>

    <script>
        let apiInstance = null;
        let connectionResults = {};

        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.innerHTML = `[${timestamp}] ${message}`;
            logEntry.className = type;
            logDiv.appendChild(logEntry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function updateStatus(message, type) {
            const statusDiv = document.getElementById('status');
            statusDiv.className = `status ${type}`;
            statusDiv.innerHTML = `<h3>${message}</h3>`;
        }

        function updateConnectionItem(name, status, message) {
            const grid = document.getElementById('connectionGrid');
            const items = grid.children;
            
            for (let item of items) {
                if (item.querySelector('h4').textContent === name) {
                    item.className = `connection-item ${status}`;
                    item.querySelector('p').textContent = message;
                    break;
                }
            }
        }

        async function testAllConnections() {
            log('üöÄ Starting comprehensive connection test...', 'info');
            
            // Test SDK detection first
            await testSDKDetection();
            
            // Test service endpoints
            await testServiceEndpoints();
            
            // Final status update
            const connectedCount = Object.values(connectionResults).filter(r => r === 'success').length;
            if (connectedCount > 0) {
                updateStatus(`‚úÖ ${connectedCount} connection(s) successful!`, 'connected');
                log(`üéâ Connection test complete: ${connectedCount} successful connection(s)`, 'success');
            } else {
                updateStatus('‚ùå No connections successful', 'disconnected');
                log('‚ö†Ô∏è No connections successful. Check BIXOLON SDK service configuration.', 'warning');
            }
        }

        async function testSDKDetection() {
            log('üîç Testing BIXOLON SDK Detection...', 'info');
            
            // Check for BIXOLON SDK in global scope
            const sdkNames = ['BixolonWebPrintSDK', 'BixolonWebPrint', 'bixolon', 'webprint'];
            const foundSDK = sdkNames.find(name => window[name]);
            
            if (foundSDK) {
                log(`‚úÖ Found BIXOLON SDK: ${foundSDK}`, 'success');
                updateConnectionItem('Global SDK', 'success', 'Found');
                connectionResults['sdk'] = 'success';
            } else {
                log('‚ö†Ô∏è BIXOLON SDK not found in global scope', 'warning');
                updateConnectionItem('Global SDK', 'failed', 'Not Found');
                connectionResults['sdk'] = 'failed';
            }

            // Check our API instance
            if (window.bGateWebPrintAPI) {
                log('‚úÖ Our BIXOLON API wrapper is available', 'success');
                apiInstance = window.bGateWebPrintAPI;
                
                const status = apiInstance.getStatus();
                log(`üìä API Status: ${JSON.stringify(status)}`, 'info');
                
                if (status.connected) {
                    log('‚úÖ API reports connected to BIXOLON printer', 'success');
                } else {
                    log('‚ö†Ô∏è API reports not connected to BIXOLON printer', 'warning');
                }
            } else {
                log('‚ùå Our BIXOLON API wrapper not found', 'error');
            }
        }

        async function testServiceEndpoints() {
            log('üåê Testing BIXOLON Service Endpoints...', 'info');
            
            const endpoints = [
                { name: 'HTTP :8080', url: 'http://localhost:8080', type: 'http' },
                { name: 'HTTP :3000', url: 'http://localhost:3000', type: 'http' },
                { name: 'HTTP :5000', url: 'http://localhost:5000', type: 'http' },
                { name: 'WebSocket :8080', url: 'ws://localhost:8080', type: 'ws' },
                { name: 'WebSocket :9100', url: 'ws://localhost:9100', type: 'ws' }
            ];

            for (const endpoint of endpoints) {
                try {
                    log(`üîç Testing ${endpoint.name}: ${endpoint.url}`, 'info');
                    
                    if (endpoint.type === 'ws') {
                        const connected = await testWebSocket(endpoint.url);
                        if (connected) {
                            log(`‚úÖ ${endpoint.name} connection successful`, 'success');
                            updateConnectionItem(endpoint.name, 'success', 'Connected');
                            connectionResults[endpoint.name] = 'success';
                        } else {
                            log(`‚ùå ${endpoint.name} connection failed`, 'error');
                            updateConnectionItem(endpoint.name, 'failed', 'Failed');
                            connectionResults[endpoint.name] = 'failed';
                        }
                    } else {
                        const connected = await testHTTP(endpoint.url);
                        if (connected) {
                            log(`‚úÖ ${endpoint.name} connection successful`, 'success');
                            updateConnectionItem(endpoint.name, 'success', 'Connected');
                            connectionResults[endpoint.name] = 'success';
                        } else {
                            log(`‚ùå ${endpoint.name} connection failed`, 'error');
                            updateConnectionItem(endpoint.name, 'failed', 'Failed');
                            connectionResults[endpoint.name] = 'failed';
                        }
                    }
                } catch (error) {
                    log(`‚ùå ${endpoint.name} test error: ${error.message}`, 'error');
                    updateConnectionItem(endpoint.name, 'failed', 'Error');
                    connectionResults[endpoint.name] = 'failed';
                }
            }
        }

        async function testWebSocket(url) {
            return new Promise((resolve) => {
                try {
                    const ws = new WebSocket(url);
                    
                    ws.onopen = () => {
                        log(`üîå WebSocket connected to: ${url}`, 'success');
                        ws.close();
                        resolve(true);
                    };
                    
                    ws.onerror = () => {
                        log(`‚ùå WebSocket error connecting to: ${url}`, 'error');
                        resolve(false);
                    };
                    
                    // Timeout after 3 seconds
                    setTimeout(() => {
                        if (ws.readyState !== WebSocket.OPEN) {
                            ws.close();
                            resolve(false);
                        }
                    }, 3000);
                    
                } catch (error) {
                    log(`‚ùå WebSocket connection failed: ${error.message}`, 'error');
                    resolve(false);
                }
            });
        }

        async function testHTTP(url) {
            try {
                // Try multiple endpoints
                const endpoints = ['', '/status', '/api/status', '/health'];
                
                for (const endpoint of endpoints) {
                    try {
                        const response = await fetch(`${url}${endpoint}`, { 
                            method: 'GET',
                            mode: 'no-cors',
                            signal: AbortSignal.timeout(3000)
                        });
                        
                        if (response.ok || response.status === 0) { // no-cors returns status 0
                            log(`‚úÖ HTTP connection successful to: ${url}${endpoint}`, 'success');
                            return true;
                        }
                    } catch (endpointError) {
                        // Continue to next endpoint
                    }
                }
                
                return false;
            } catch (error) {
                log(`‚ùå HTTP connection failed: ${error.message}`, 'error');
                return false;
            }
        }

        async function testPrintJob() {
            log('üñ®Ô∏è Testing BIXOLON Print Job...', 'info');
            
            if (!apiInstance) {
                log('‚ùå No API instance available. Run connection tests first.', 'error');
                return;
            }

            if (!apiInstance.connected) {
                log('‚ùå Not connected to BIXOLON printer. Run connection tests first.', 'error');
                return;
            }

            try {
                const printJob = apiInstance.createPrintJob({
                    width: 80,
                    fontSize: 11,
                    fontFamily: 'monospace',
                    lineSpacing: 1.2,
                    margin: 0
                });

                log('‚úÖ Print job created successfully', 'success');

                // Add test content
                printJob.addText('BETZONE SERVICE TEST');
                printJob.addLineBreak();
                printJob.addSeparator('=');
                printJob.addText('Date: ' + new Date().toLocaleString());
                printJob.addText('Test: BIXOLON Service Connection');
                printJob.addLineBreak();
                printJob.addSeparator('=');
                printJob.addText('This tests the service connection');
                printJob.addText('to your remote BIXOLON printer');
                printJob.addLineBreak();
                printJob.addText('Thank you for testing!');

                log('‚úÖ Content added to print job', 'success');

                // Execute the print job
                const result = await printJob.execute();
                log(`‚úÖ Print job completed: ${JSON.stringify(result)}`, 'success');

            } catch (error) {
                log(`‚ùå Print job test failed: ${error.message}`, 'error');
            }
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
            log('üßπ Log cleared', 'info');
        }

        // Auto-run tests when page loads
        window.addEventListener('load', () => {
            log('üöÄ Page loaded, starting BIXOLON service tests...', 'info');
            setTimeout(() => {
                testAllConnections();
            }, 1000);
        });
    </script>
</body>
</html>
